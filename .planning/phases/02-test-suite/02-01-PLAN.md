---
phase: 02-test-suite
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - vitest.config.ts
  - package.json
  - src/test-helpers.ts
  - src/services/peer-registry.test.ts
  - src/services/cc-cli.test.ts
  - src/config.test.ts
  - src/errors.test.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Running `npm test` executes Vitest and reports results"
    - "Peer registry tests verify register, deregister, list, state persistence, and corrupt state recovery using isolated temp dirs"
    - "CLI service tests verify success, timeout, and error paths using mocked execFile"
    - "Config tests verify loading, validation, reset, and frozen singleton behavior"
    - "No test touches shared /tmp or ~/cloud_code_bridge -- all use mkdtemp temp dirs"
  artifacts:
    - path: "vitest.config.ts"
      provides: "Vitest configuration with Node16 ESM extension resolution and v8 coverage"
      contains: "resolve.extensions"
    - path: "src/test-helpers.ts"
      provides: "createTestConfig helper for isolated temp dir + config setup"
      exports: ["createTestConfig"]
    - path: "src/services/peer-registry.test.ts"
      provides: "Peer registry service tests (TEST-02, TEST-05)"
      min_lines: 80
    - path: "src/services/cc-cli.test.ts"
      provides: "CLI service tests with mocked execFile (TEST-03)"
      min_lines: 60
    - path: "src/config.test.ts"
      provides: "Config module tests"
      min_lines: 30
    - path: "src/errors.test.ts"
      provides: "Error helper tests"
      min_lines: 20
  key_links:
    - from: "src/test-helpers.ts"
      to: "src/config.ts"
      via: "resetConfig() + loadConfig(env)"
      pattern: "resetConfig.*loadConfig"
    - from: "src/services/peer-registry.test.ts"
      to: "src/test-helpers.ts"
      via: "createTestConfig for temp dir isolation"
      pattern: "createTestConfig"
    - from: "src/services/cc-cli.test.ts"
      to: "node:child_process"
      via: "vi.mock for execFile interception"
      pattern: "vi\\.mock.*node:child_process"
---

<objective>
Install Vitest, create test infrastructure, and write service-layer tests for peer-registry and cc-cli.

Purpose: Establish the test foundation (vitest config, helpers, npm scripts) and test the two service modules that contain all core business logic -- file-based state management with locking (peer-registry) and CLI subprocess execution (cc-cli). Also test config and error utility modules.

Output: Working `npm test` command, test helper for isolated config/temp dirs, and passing tests for both services plus config/errors modules.
</objective>

<execution_context>
@/Users/dev/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-test-suite/02-RESEARCH.md
@src/config.ts
@src/errors.ts
@src/types.ts
@src/logger.ts
@src/services/peer-registry.ts
@src/services/cc-cli.ts
@package.json
@tsconfig.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Vitest, create vitest.config.ts, test-helpers.ts, and npm scripts</name>
  <files>
    vitest.config.ts
    package.json
    src/test-helpers.ts
  </files>
  <action>
1. Install dev dependencies:
   ```
   npm install -D vitest @vitest/coverage-v8
   ```

2. Create `vitest.config.ts` at project root with this exact configuration:
   ```typescript
   import { defineConfig } from "vitest/config";

   export default defineConfig({
     resolve: {
       extensions: [".ts", ".js", ".json"],
     },
     test: {
       globals: false,
       environment: "node",
       include: ["src/**/*.test.ts"],
       testTimeout: 10_000,
       coverage: {
         provider: "v8",
         include: ["src/**/*.ts"],
         exclude: ["src/**/*.test.ts", "src/index.ts"],
         reporter: ["text", "json", "html"],
       },
     },
   });
   ```
   The `resolve.extensions` setting is CRITICAL -- it makes Vite resolve `.js` imports to `.ts` source files (the codebase uses Node16 module resolution with `.js` extensions everywhere).

3. Add test scripts to `package.json` scripts:
   ```json
   "test": "vitest run",
   "test:watch": "vitest",
   "test:coverage": "vitest run --coverage"
   ```

4. Create `src/test-helpers.ts` with a `createTestConfig()` helper:
   ```typescript
   import { mkdtemp, rm } from "node:fs/promises";
   import { tmpdir } from "node:os";
   import { join } from "node:path";
   import { resetConfig, loadConfig } from "./config.js";

   export async function createTestConfig(): Promise<{
     tempDir: string;
     cleanup: () => Promise<void>;
   }> {
     const tempDir = await mkdtemp(join(tmpdir(), "cc-bridge-test-"));
     resetConfig();
     loadConfig({
       CC_BRIDGE_STATE_PATH: tempDir,
       CC_BRIDGE_TIMEOUT_MS: "5000",
       CC_BRIDGE_CHAR_LIMIT: "0",
       CC_BRIDGE_LOG_LEVEL: "error",
       CC_BRIDGE_CLAUDE_PATH: "claude",
     });
     return {
       tempDir,
       cleanup: async () => {
         resetConfig();
         await rm(tempDir, { recursive: true, force: true });
       },
     };
   }
   ```
   - Uses `CC_BRIDGE_LOG_LEVEL: "error"` to suppress noisy log output during tests
   - Each call creates a unique mkdtemp directory, ensuring test isolation (TEST-05)
   - `cleanup()` resets config singleton AND removes temp dir

5. Update `tsconfig.json` to exclude test files from compilation output (add to exclude array): `"src/**/*.test.ts"` and `"src/test-helpers.ts"`. This prevents test files from appearing in `dist/`.
  </action>
  <verify>
Run `npx vitest run` -- should complete with 0 test files found (no tests written yet) but no configuration errors. Verify it does NOT fail with module resolution issues.
Also verify `npx tsc --noEmit` still passes (tsconfig exclude doesn't break anything).
  </verify>
  <done>
vitest.config.ts exists with correct resolve.extensions. package.json has test/test:watch/test:coverage scripts. src/test-helpers.ts exports createTestConfig(). `npm test` runs without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write peer-registry service tests (TEST-02, TEST-05)</name>
  <files>
    src/services/peer-registry.test.ts
  </files>
  <action>
Create `src/services/peer-registry.test.ts` testing the peer-registry service directly (not through MCP protocol -- that's for tool handler tests). Use real filesystem with isolated temp dirs via `createTestConfig()`.

Test the following behaviors with `describe` blocks:

**registerPeer:**
- Creates a new peer entry; returned PeerInfo has peerId, sessionId, cwd, label, registeredAt
- Overwrites existing peer with same ID (returns updated data, listPeers still shows 1)
- Persists across separate readState calls (register, then getPeer in new call confirms persistence)

**deregisterPeer:**
- Returns true when peer existed, getPeer returns undefined after
- Returns false when peer did not exist

**listPeers:**
- Returns empty array initially
- Returns all registered peers

**getPeer:**
- Returns undefined for nonexistent peer
- Returns PeerInfo for registered peer

**recordMessage + getHistory:**
- Records a message and retrieves it; verify id (UUID format) and timestamp are auto-assigned
- Filters by peerId (messages where peerId is sender OR recipient)
- Respects limit parameter (record 3, get with limit 2, expect 2 returned -- the most recent 2)
- Messages persist to state file (record, then read from fresh getHistory call)

**Corrupt state recovery (from Phase 1 decision 01-03):**
- Write invalid JSON to the state file path, then call listPeers -- should return empty array (auto-recovery)
- After recovery, registerPeer should work (state is usable again)

**State isolation (TEST-05):**
- Each test uses its own temp dir via createTestConfig (enforced by beforeEach/afterEach pattern)
- Confirm no test writes to ~/cloud_code_bridge or /tmp/cc-bridge-state.json

Import `registerPeer, deregisterPeer, listPeers, getPeer, recordMessage, getHistory` from `"./peer-registry.js"`.

Use this beforeEach/afterEach pattern:
```typescript
let cleanup: () => Promise<void>;
let tempDir: string;

beforeEach(async () => {
  const ctx = await createTestConfig();
  cleanup = ctx.cleanup;
  tempDir = ctx.tempDir;
});

afterEach(async () => {
  await cleanup();
});
```

For the corrupt state test, write invalid JSON directly to `path.join(tempDir, "cc-bridge-state.json")` using `fs.writeFile` before calling the service function.

For recordMessage, use the Omit<MessageRecord, "id" | "timestamp"> shape:
```typescript
{ fromPeerId: "be", toPeerId: "fe", message: "hello", response: "hi", durationMs: 100, success: true, error: null }
```
  </action>
  <verify>
Run `npx vitest run src/services/peer-registry.test.ts` -- all tests pass. Verify no files created in ~/cloud_code_bridge or /tmp/cc-bridge-state.json.
  </verify>
  <done>
peer-registry.test.ts has tests for register, deregister, list, getPeer, recordMessage, getHistory, corrupt state recovery, and state isolation. All pass with real filesystem + isolated temp dirs.
  </done>
</task>

<task type="auto">
  <name>Task 3: Write cc-cli service tests (TEST-03) and config/errors tests</name>
  <files>
    src/services/cc-cli.test.ts
    src/config.test.ts
    src/errors.test.ts
  </files>
  <action>
**cc-cli.test.ts (TEST-03):**

Create `src/services/cc-cli.test.ts` with mocked `node:child_process`. The mock intercepts `execFile` so no real subprocess is spawned.

Structure:
```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";
import { execFile } from "node:child_process";
import { createTestConfig } from "../test-helpers.js";

vi.mock("node:child_process", () => ({
  execFile: vi.fn(),
}));

const mockExecFile = vi.mocked(execFile);
const { execClaude } = await import("./cc-cli.js");
```

Test cases:
- **Success path:** mockExecFile calls callback with `(null, "Claude response", "")`. Verify result has `stdout: "Claude response"`, `stderr: ""`, `exitCode: 0`.
- **Timeout path:** mockExecFile calls callback with error having `killed: true, signal: "SIGTERM", code: null`. Verify result.stderr contains "CLI_TIMEOUT", result.exitCode is null.
- **Missing binary (ENOENT):** mockExecFile calls callback with error having `code: "ENOENT"`. Verify result.stderr contains "CLI_NOT_FOUND", result.exitCode is 127.
- **General failure:** mockExecFile calls callback with error having `code: 1` and stderr "some error". Verify result.stderr contains "CLI_EXEC_FAILED".
- **Character truncation:** Set config with `CC_BRIDGE_CHAR_LIMIT: "100"` via createTestConfig override, send message longer than 100 chars. Verify mockExecFile was called with truncated message in args (check `mockExecFile.mock.calls[0][1]` for the `-p` arg). For this test, override the config: `resetConfig(); loadConfig({ ...baseEnv, CC_BRIDGE_CHAR_LIMIT: "100" })`.

IMPORTANT: The mockExecFile.mockImplementation must accept 4 parameters `(_cmd, _args, _opts, callback)` because execClaude uses the 4-argument form of execFile. Use `as any` for types where needed.

Use beforeEach to call `vi.clearAllMocks()` and `createTestConfig()`, afterEach to call cleanup.

**config.test.ts:**

Create `src/config.test.ts` testing the config module:
- `loadConfig()` with no env returns defaults (state path contains "cloud_code_bridge", timeout 120000, char limit 0, log level "info", claude path "claude")
- `loadConfig()` with custom env overrides all values
- `getConfig()` throws if called before loadConfig
- `resetConfig()` + `getConfig()` throws (config cleared)
- Config is frozen (attempting to modify a property throws TypeError)
- Invalid values (e.g., `CC_BRIDGE_TIMEOUT_MS: "abc"`) throw with descriptive error

Use `resetConfig()` in beforeEach to ensure clean state. Do NOT use createTestConfig here since we're testing config itself.

**errors.test.ts:**

Create `src/errors.test.ts` testing error utilities:
- `BridgeError` has correct message format: `"CODE: message. suggestion"` (with suggestion) and `"CODE: message"` (without)
- `BridgeError.code` and `BridgeError.suggestion` are accessible
- `toolResult("text")` returns `{ content: [{ type: "text", text: "text" }] }` without isError
- `toolResult("text", true)` returns object with `isError: true`
- `errorResult(new BridgeError(...))` returns JSON with success:false, error code, message, suggestion
- `errorResult(new Error("generic"))` returns JSON with success:false, error: "INTERNAL_ERROR"
- `successResult({ foo: "bar" })` returns JSON-stringified content without isError
  </action>
  <verify>
Run `npx vitest run src/services/cc-cli.test.ts src/config.test.ts src/errors.test.ts` -- all tests pass.
Then run `npm test` to verify ALL tests (including peer-registry from Task 2) pass together without interference.
  </verify>
  <done>
cc-cli.test.ts covers success, timeout, ENOENT, general failure, and char truncation with mocked execFile. config.test.ts covers load, defaults, overrides, reset, frozen, and validation. errors.test.ts covers BridgeError, toolResult, errorResult, successResult. All pass together via `npm test`.
  </done>
</task>

</tasks>

<verification>
1. `npm test` executes all test files and reports pass/fail
2. `npx vitest run --coverage` shows coverage for src/ (excluding test files and index.ts)
3. No test creates files in ~/cloud_code_bridge or shared /tmp locations
4. Tests pass in isolation (`vitest run src/specific.test.ts`) AND together (`vitest run`)
5. `npx tsc --noEmit` still passes (test files excluded from compilation)
</verification>

<success_criteria>
- All service tests pass: peer-registry (register, deregister, list, getPeer, recordMessage, getHistory, corrupt recovery) and cc-cli (success, timeout, ENOENT, failure, truncation)
- Config and error utility tests pass
- Test infrastructure established: vitest.config.ts, test-helpers.ts, npm scripts
- Every test uses isolated temp directories via createTestConfig (TEST-05)
- `npm test` runs cleanly with no errors
</success_criteria>

<output>
After completion, create `.planning/phases/02-test-suite/02-01-SUMMARY.md`
</output>
