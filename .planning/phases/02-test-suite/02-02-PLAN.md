---
phase: 02-test-suite
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - src/tools/register-peer.test.ts
  - src/tools/deregister-peer.test.ts
  - src/tools/send-message.test.ts
  - src/tools/list-peers.test.ts
  - src/tools/get-history.test.ts
  - src/integration.test.ts
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Each of the 5 tool handlers has tests verifying correct MCP responses for valid input"
    - "Each of the 5 tool handlers has tests verifying proper error responses for invalid/edge-case input"
    - "Tool tests exercise Zod validation, error wrapping, and MCP response formatting via InMemoryTransport"
    - "All tool tests use isolated temp dirs and do not pollute shared state"
  artifacts:
    - path: "src/tools/register-peer.test.ts"
      provides: "cc_register_peer tool handler tests"
      min_lines: 40
    - path: "src/tools/deregister-peer.test.ts"
      provides: "cc_deregister_peer tool handler tests"
      min_lines: 30
    - path: "src/tools/send-message.test.ts"
      provides: "cc_send_message tool handler tests"
      min_lines: 60
    - path: "src/tools/list-peers.test.ts"
      provides: "cc_list_peers tool handler tests"
      min_lines: 30
    - path: "src/tools/get-history.test.ts"
      provides: "cc_get_history tool handler tests"
      min_lines: 30
  key_links:
    - from: "src/tools/*.test.ts"
      to: "@modelcontextprotocol/sdk"
      via: "InMemoryTransport + Client.callTool()"
      pattern: "InMemoryTransport\\.createLinkedPair"
    - from: "src/tools/*.test.ts"
      to: "src/test-helpers.ts"
      via: "createTestConfig for isolation"
      pattern: "createTestConfig"
    - from: "src/tools/send-message.test.ts"
      to: "node:child_process"
      via: "vi.mock for execFile (send-message calls execClaude)"
      pattern: "vi\\.mock.*node:child_process"
---

<objective>
Write unit tests for all 5 tool handlers via InMemoryTransport, verifying correct MCP responses for valid input and proper error handling for invalid/edge-case input.

Purpose: TEST-01 requires each tool handler to have tests that verify the full MCP protocol path -- Zod validation, business logic, error wrapping, and response formatting. Testing through InMemoryTransport + Client.callTool() exercises the complete stack that a real MCP client would use.

Output: 5 test files (one per tool) all passing via `npm test`.
</objective>

<execution_context>
@/Users/dev/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-test-suite/02-RESEARCH.md
@.planning/phases/02-test-suite/02-01-SUMMARY.md
@src/tools/register-peer.ts
@src/tools/deregister-peer.ts
@src/tools/send-message.ts
@src/tools/list-peers.ts
@src/tools/get-history.ts
@src/types.ts
@src/errors.ts
@src/test-helpers.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Write tool handler tests for register-peer, deregister-peer, and list-peers</name>
  <files>
    src/tools/register-peer.test.ts
    src/tools/deregister-peer.test.ts
    src/tools/list-peers.test.ts
  </files>
  <action>
For each tool test file, use this shared pattern to set up an MCP server with just the tool under test, connect a Client via InMemoryTransport, and call the tool:

```typescript
import { describe, it, expect, beforeEach, afterEach } from "vitest";
import { Client } from "@modelcontextprotocol/sdk/client/index.js";
import { InMemoryTransport } from "@modelcontextprotocol/sdk/inMemory.js";
import { McpServer } from "@modelcontextprotocol/sdk/server/mcp.js";
import { createTestConfig } from "../test-helpers.js";

let client: Client;
let server: McpServer;
let cleanup: () => Promise<void>;

beforeEach(async () => {
  const ctx = await createTestConfig();
  cleanup = ctx.cleanup;
  server = new McpServer({ name: "test", version: "1.0.0" });
  // Register the tool under test
  registerXxxTool(server);
  const [ct, st] = InMemoryTransport.createLinkedPair();
  client = new Client({ name: "test-client", version: "1.0.0" });
  await Promise.all([server.connect(st), client.connect(ct)]);
});

afterEach(async () => {
  await client.close();
  await server.close();
  await cleanup();
});
```

Parse results as: `const data = JSON.parse((result.content as Array<{type: string; text: string}>)[0].text);`

**register-peer.test.ts:**
- "registers a new peer and returns success" -- call with valid args, verify `data.success === true`, `data.action === "registered"`, `data.peer.peerId` matches
- "returns updated when re-registering same peerId" -- register once, register again with same peerId but different sessionId, verify `data.action === "updated"`
- "returns peer with registeredAt timestamp" -- verify `data.peer.registeredAt` is a valid ISO string

**deregister-peer.test.ts:**
- "returns success:true when peer existed" -- register a peer first, then deregister, verify `data.success === true`
- "returns success:false when peer did not exist" -- deregister nonexistent peer, verify `data.success === false` (note: deregisterPeer returns false, tool handler wraps in successResult with `success: removed`)
- "deregistered peer no longer appears in list" -- register peer, deregister, then use list-peers to verify. For this test, also register registerListPeersTool on the same server so you can call cc_list_peers after deregistering.

**list-peers.test.ts:**
- "returns empty array when no peers registered" -- call immediately, verify `data.peers` is `[]` and `data.count === 0`
- "returns all registered peers" -- register 2 peers (also register registerRegisterPeerTool on server), call list, verify `data.count === 2`
- "returns peer details including all fields" -- register a peer, call list, verify returned peer has peerId, sessionId, cwd, label, registeredAt

For deregister and list tests that need to register peers first: register BOTH the tool under test AND registerRegisterPeerTool on the same McpServer instance so you can call cc_register_peer to set up test data.
  </action>
  <verify>
Run `npx vitest run src/tools/register-peer.test.ts src/tools/deregister-peer.test.ts src/tools/list-peers.test.ts` -- all tests pass.
  </verify>
  <done>
register-peer.test.ts: 3+ tests covering new registration, re-registration, and timestamp.
deregister-peer.test.ts: 3+ tests covering existing peer removal, nonexistent peer, and list verification.
list-peers.test.ts: 3+ tests covering empty list, multiple peers, and field completeness.
All pass via InMemoryTransport with isolated temp dirs.
  </done>
</task>

<task type="auto">
  <name>Task 2: Write tool handler tests for send-message and get-history, plus integration test</name>
  <files>
    src/tools/send-message.test.ts
    src/tools/get-history.test.ts
    src/integration.test.ts
  </files>
  <action>
**send-message.test.ts:**

This test requires mocking `node:child_process` because send-message calls `execClaude` which calls `execFile`. Set up the mock BEFORE imports:

```typescript
import { describe, it, expect, vi, beforeEach, afterEach } from "vitest";
import { execFile } from "node:child_process";

vi.mock("node:child_process", () => ({
  execFile: vi.fn(),
}));

const mockExecFile = vi.mocked(execFile);
```

Then import the tool registration function and MCP SDK classes. Register `registerSendMessageTool` AND `registerRegisterPeerTool` on the server (send-message needs registered peers).

Test cases:
- "sends message successfully and returns response" -- register 2 peers, mock execFile to call callback with `(null, "Got it!", "")`, send message from peer1 to peer2. Verify `data.success === true`, `data.response === "Got it!"`.
- "returns error when sender peer not registered" -- register only the target peer, send from nonexistent sender. Verify `result.isError === true` (or check `data.success === false`), `data.error === "PEER_NOT_FOUND"`.
- "returns error when target peer not registered" -- register only the sender, send to nonexistent target. Verify PEER_NOT_FOUND error.
- "handles CLI timeout" -- mock execFile with killed/SIGTERM error, verify result contains timeout info (`data.success === false`, `data.error` contains "CLI_TIMEOUT").
- "records message in history" -- send a successful message, then also register registerGetHistoryTool on server, call cc_get_history, verify the message appears.

IMPORTANT: Call `vi.clearAllMocks()` in beforeEach.

**get-history.test.ts:**

Register `registerGetHistoryTool` AND `registerRegisterPeerTool` AND `registerSendMessageTool` on the server. Mock `node:child_process` same as send-message test.

Test cases:
- "returns empty array when no messages" -- call cc_get_history, verify `data.messages` is `[]`, `data.count === 0`
- "returns messages after sending" -- register 2 peers, mock CLI success, send a message, get history, verify 1 message with correct fromPeerId, toPeerId, message text
- "filters by peerId" -- send messages between different peer pairs, get history filtered by one peerId, verify only relevant messages returned
- "respects limit parameter" -- send 3 messages, get history with limit:2, verify only 2 returned (most recent)
- "returns messages without peerId filter" -- send messages, get history without peerId, verify all returned

**integration.test.ts (TEST-04):**

Full register-send-history-deregister workflow via InMemoryTransport. Register ALL 5 tools on one McpServer. Mock `node:child_process`.

Single test case "register -> send -> history -> deregister" that exercises the complete workflow:

1. Register "backend" peer -- verify success
2. Register "frontend" peer -- verify success
3. List peers -- verify count === 2
4. Mock execFile for success, send message from backend to frontend -- verify response
5. Get history for "backend" -- verify 1 message with correct fields
6. Deregister "backend" -- verify success
7. List peers -- verify count === 1, only "frontend" remains
8. Get history (unfiltered) -- verify message still in history after deregister

This test proves the full system works end-to-end through the MCP protocol without touching shared filesystem (TEST-04 + TEST-05).
  </action>
  <verify>
Run `npx vitest run src/tools/send-message.test.ts src/tools/get-history.test.ts src/integration.test.ts` -- all pass.
Then run `npm test` to verify ALL tests across the entire suite pass together (both Plan 01 and Plan 02 tests).
Finally run `npx vitest run --coverage` and confirm coverage report is generated.
  </verify>
  <done>
send-message.test.ts: 5+ tests covering success, sender not found, target not found, CLI timeout, and history recording.
get-history.test.ts: 5+ tests covering empty, after sending, filtering, limit, and unfiltered.
integration.test.ts: 1 comprehensive test exercising full register-send-history-deregister workflow.
All 5 tool handlers have unit tests (TEST-01). Full workflow integration test passes (TEST-04). `npm test` runs all tests successfully. Coverage report generated.
  </done>
</task>

</tasks>

<verification>
1. `npm test` runs all test files (services, tools, integration, config, errors) and ALL pass
2. Each of the 5 tool handlers has its own test file with valid-input and error-case tests (TEST-01)
3. Integration test completes full register-send-history-deregister cycle (TEST-04)
4. `npx vitest run --coverage` generates coverage report with meaningful numbers
5. No test writes to ~/cloud_code_bridge or shared /tmp (TEST-05)
6. Tests pass individually AND together (no config singleton leaking between tests)
</verification>

<success_criteria>
- 5 tool handler test files exist and pass (TEST-01 complete)
- Integration test passes full workflow via InMemoryTransport (TEST-04 complete)
- `npm test` reports 0 failures across all test files
- Coverage report shows meaningful coverage for all src/ modules (excluding index.ts)
</success_criteria>

<output>
After completion, create `.planning/phases/02-test-suite/02-02-SUMMARY.md`
</output>
