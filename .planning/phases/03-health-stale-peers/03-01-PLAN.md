---
phase: 03-health-stale-peers
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/services/health-check.ts
  - src/tools/health-check.ts
  - src/index.ts
  - src/services/health-check.test.ts
  - src/tools/health-check.test.ts
autonomous: true

must_haves:
  truths:
    - "Calling cc_health_check with a working setup returns success confirming state file, lock mechanism, and claude CLI are all operational"
    - "Calling cc_health_check when claude is missing from PATH returns a response identifying the specific failure"
    - "Health check does not mutate state or interfere with concurrent operations"
  artifacts:
    - path: "src/services/health-check.ts"
      provides: "checkHealth() service function with three sub-checks"
      exports: ["checkHealth"]
    - path: "src/tools/health-check.ts"
      provides: "registerHealthCheckTool() thin MCP tool wrapper"
      exports: ["registerHealthCheckTool"]
    - path: "src/services/health-check.test.ts"
      provides: "Unit tests for health check service"
      contains: "checkHealth"
    - path: "src/tools/health-check.test.ts"
      provides: "Tool handler tests via InMemoryTransport"
      contains: "cc_health_check"
  key_links:
    - from: "src/tools/health-check.ts"
      to: "src/services/health-check.ts"
      via: "import checkHealth"
      pattern: "import.*checkHealth.*health-check"
    - from: "src/index.ts"
      to: "src/tools/health-check.ts"
      via: "registerHealthCheckTool(server)"
      pattern: "registerHealthCheckTool"
    - from: "src/services/health-check.ts"
      to: "src/config.ts"
      via: "getConfig() for state path and claude path"
      pattern: "getConfig\\(\\)"
---

<objective>
Implement the cc_health_check MCP tool that diagnoses bridge operational status by checking state file accessibility, lock mechanism, and Claude CLI availability.

Purpose: Users can diagnose bridge problems with a single tool call instead of manually checking files and CLI availability. Covers requirements HLTH-01, HLTH-02, HLTH-03.
Output: New health-check service, tool handler, tests, and tool registration in index.ts.
</objective>

<execution_context>
@/Users/dev/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-health-stale-peers/03-RESEARCH.md

@src/services/peer-registry.ts
@src/tools/list-peers.ts
@src/startup.ts
@src/config.ts
@src/errors.ts
@src/types.ts
@src/constants.ts
@src/index.ts
@src/test-helpers.ts
@src/tools/list-peers.test.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create health-check service and tool handler</name>
  <files>
    src/services/health-check.ts
    src/tools/health-check.ts
    src/index.ts
  </files>
  <action>
Create `src/services/health-check.ts` with three sub-check functions and a `checkHealth()` orchestrator:

1. Define types locally in the file (not in types.ts -- they are only used here):
   ```
   interface CheckResult { ok: boolean; message: string }
   interface HealthCheckResult {
     healthy: boolean;
     serverVersion: string;
     statePath: string;
     claudePath: string;
     checks: {
       stateFile: CheckResult;
       lockMechanism: CheckResult;
       claudeCli: CheckResult & { version?: string };
     };
     timestamp: string;
   }
   ```

2. `checkStateFile()` -- (HLTH-01):
   - Get statePath from `getStatePath()` (same derivation as peer-registry: `path.join(getConfig().CC_BRIDGE_STATE_PATH, "cc-bridge-state.json")`)
   - Check dir is readable+writable via `fs.access(path.dirname(statePath), fs.constants.R_OK | fs.constants.W_OK)`
   - If state file exists, read it and verify it parses as JSON
   - If state file does not exist (ENOENT), report ok with "State directory writable (no state file yet)"
   - If state file exists but is corrupt JSON, report NOT ok with "State file exists but contains invalid JSON"
   - If dir not accessible, report NOT ok with path in message

3. `checkLockMechanism()` -- (HLTH-02):
   - Use a SEPARATE health-check lock path: `getStatePath() + ".health-lock"` (NOT the real lock path). This avoids interfering with concurrent real operations per research pitfall #5.
   - Try `fs.writeFile(healthLockPath, String(process.pid), { flag: "wx" })` then immediately `fs.unlink(healthLockPath)` in a try/finally
   - If success: ok with "Lock acquire/release cycle succeeded"
   - If EEXIST: NOT ok with "Health check lock file exists unexpectedly" (should never happen since we use separate path)
   - Any other error: NOT ok with error message

4. `checkClaudeCli()` -- (HLTH-03):
   - `execFile(getConfig().CC_BRIDGE_CLAUDE_PATH, ["--version"], { timeout: 5000 })` using `promisify(execFile)`
   - On success: ok with "Claude CLI found", include `version: stdout.trim()`
   - On failure: NOT ok with `Claude CLI not found at '${claudePath}'`

5. `checkHealth()` export:
   - Runs all three checks (not short-circuiting -- run all even if one fails)
   - Returns HealthCheckResult with `healthy: Object.values(checks).every(c => c.ok)`, plus `serverVersion` from constants, `statePath` from config, `claudePath` from config, `timestamp` as ISO string

Import pattern: Use `getConfig` from `../config.js`, `SERVER_VERSION` from `../constants.js`, node builtins with `node:` prefix. Do NOT import logger -- health check is a pure diagnostic that returns results, not logs them.

Create `src/tools/health-check.ts`:
- Export `registerHealthCheckTool(server: McpServer): void`
- Follow exact pattern from `list-peers.ts`: no inputSchema (empty object `{}`), `annotations: { readOnlyHint: true, destructiveHint: false, idempotentHint: true, openWorldHint: false }`
- Handler: `try { const result = await checkHealth(); return successResult(result as unknown as Record<string, unknown>); } catch (err) { logger.error("health-check failed", { error: err }); return errorResult(err); }`
- The `as unknown as Record<string, unknown>` cast is needed because `successResult` expects `Record<string, unknown>` but HealthCheckResult has nested objects. Alternatively, spread into a plain object or use `JSON.parse(JSON.stringify(result))`.
- Title: "Health Check", description: "Diagnose the bridge's operational status. Checks state file accessibility, lock mechanism, and Claude CLI availability. Returns per-check pass/fail with details."

Update `src/index.ts`:
- Add import: `import { registerHealthCheckTool } from "./tools/health-check.js";`
- Add registration call after existing tools: `registerHealthCheckTool(server);`
- Update the logger.info ready message to include `cc_health_check` in the tool list
  </action>
  <verify>Run `npx tsc --noEmit` to confirm no type errors. Run `npm test` to confirm existing tests still pass (no regressions from index.ts change).</verify>
  <done>health-check service with three sub-checks exists, tool handler registered in index.ts, project compiles without errors, existing tests pass.</done>
</task>

<task type="auto">
  <name>Task 2: Add health-check service and tool tests</name>
  <files>
    src/services/health-check.test.ts
    src/tools/health-check.test.ts
  </files>
  <action>
Create `src/services/health-check.test.ts`:
- Import `createTestConfig` from `../test-helpers.js`, `checkHealth` from service, `vi` from vitest
- Use beforeEach/afterEach with createTestConfig pattern for temp dir isolation
- Mock `node:child_process` using `vi.mock("node:child_process", ...)` same pattern as cc-cli.test.ts

Test cases (describe "health-check service"):
1. "returns healthy when everything works" -- mock execFile to call back with (null, "claude 1.0.39\n", ""). Assert result.healthy === true, all three checks .ok === true, claudeCli.version is "claude 1.0.39", serverVersion is defined, statePath and claudePath are defined, timestamp is ISO string.
2. "reports stateFile not ok when state dir is not accessible" -- after createTestConfig, remove the temp dir (`await rm(tempDir, { recursive: true, force: true })`), then call checkHealth(). Assert checks.stateFile.ok === false, healthy === false. Other checks may also fail (lock will fail since dir is gone) -- that is fine.
3. "reports claudeCli not ok when claude is missing" -- mock execFile to call back with an ENOENT error. Assert checks.claudeCli.ok === false, message contains "not found", healthy === false. State and lock checks should still be ok (temp dir exists).
4. "reports lockMechanism ok with valid filesystem" -- covered by test 1, but can add explicit assertion on checks.lockMechanism.ok === true.
5. "handles corrupt state file gracefully" -- write invalid JSON to cc-bridge-state.json in temp dir before calling checkHealth(). Assert checks.stateFile.ok === false, message contains "invalid JSON".
6. "includes serverVersion in response" -- assert result.serverVersion matches SERVER_VERSION constant.

Create `src/tools/health-check.test.ts`:
- Follow exact pattern from `list-peers.test.ts`: InMemoryTransport.createLinkedPair(), McpServer, Client, createTestConfig
- Mock `node:child_process` for claude CLI check
- Register only registerHealthCheckTool on the server

Test cases (describe "cc_health_check tool"):
1. "returns healthy status via MCP" -- mock execFile success, call `client.callTool({ name: "cc_health_check", arguments: {} })`. Parse JSON from result.content[0].text. Assert parsed.healthy === true, isError is falsy.
2. "returns unhealthy when CLI missing via MCP" -- mock execFile ENOENT, call tool. Assert parsed.healthy === false, parsed.checks.claudeCli.ok === false, isError is falsy (the tool returns success with unhealthy data, not an MCP error).
3. "handles unexpected errors gracefully" -- this is the outer catch path. Could mock the config to return something that causes checkHealth to throw. Assert result.isError === true.

For the execFile mock pattern, replicate exactly what cc-cli.test.ts does:
```typescript
vi.mock("node:child_process", () => ({
  execFile: vi.fn(),
}));
```
Then in each test, cast and set the mock implementation:
```typescript
const { execFile } = await import("node:child_process");
const mockExecFile = execFile as unknown as ReturnType<typeof vi.fn>;
mockExecFile.mockImplementation((_cmd: string, _args: string[], _opts: unknown, cb: Function) => {
  cb(null, "claude 1.0.39\n", "");
});
```
  </action>
  <verify>Run `npm test` -- all tests pass including new health-check tests. Run `npm test -- --coverage` to confirm health-check.ts service and tool have coverage.</verify>
  <done>Health check service tests cover healthy, unhealthy (missing CLI, corrupt state, inaccessible dir) scenarios. Tool tests verify MCP protocol integration. All tests pass.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` -- no type errors
2. `npm test` -- all tests pass (existing + new health-check tests)
3. Manual verification: the tool response shape matches the expected JSON from research (healthy: true/false, checks object with three sub-checks, serverVersion, statePath, claudePath, timestamp)
</verification>

<success_criteria>
- cc_health_check tool is registered and callable via MCP
- Healthy setup produces { healthy: true } with all three checks passing
- Missing claude CLI produces { healthy: false } with claudeCli.ok === false
- Inaccessible state dir produces { healthy: false } with stateFile.ok === false
- Health check uses separate lock file (not production lock)
- All existing tests still pass (no regressions)
- New tests cover all three sub-checks in isolation
</success_criteria>

<output>
After completion, create `.planning/phases/03-health-stale-peers/03-01-SUMMARY.md`
</output>
