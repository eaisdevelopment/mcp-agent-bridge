---
phase: 05-documentation-and-registry
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - README.md
  - server.json
  - package.json
autonomous: true

must_haves:
  truths:
    - "README leads with npx installation and copy-paste .mcp.json block"
    - "README documents all 6 CC_BRIDGE_* environment variables with defaults"
    - "README documents all 6 tools including cc_health_check"
    - "README includes troubleshooting section covering NVM/PATH, state location, and error codes"
    - "server.json exists with valid MCP Registry schema"
    - "package.json contains mcpName field matching server.json name"
  artifacts:
    - path: "README.md"
      provides: "Complete user-facing documentation"
      contains: "npx cc-bridge-mcp-server"
    - path: "server.json"
      provides: "MCP Registry metadata"
      contains: "$schema"
    - path: "package.json"
      provides: "mcpName field for registry verification"
      contains: "mcpName"
  key_links:
    - from: "server.json"
      to: "package.json"
      via: "version and mcpName must match"
      pattern: "0\\.1\\.0"
    - from: "README.md"
      to: "src/config.ts"
      via: "env var documentation accuracy"
      pattern: "CC_BRIDGE_"
---

<objective>
Rewrite README.md as npx-first user documentation, create server.json for MCP Registry, and add mcpName to package.json.

Purpose: A new user can install, configure, troubleshoot, and use the bridge by reading only the README. The server.json and mcpName prepare the package for MCP Registry submission in Plan 02.
Output: README.md (complete rewrite), server.json (new), package.json (mcpName added)
</objective>

<execution_context>
@/Users/dev/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-documentation-and-registry/05-RESEARCH.md

# Source files for accurate documentation
@src/config.ts
@src/errors.ts
@src/index.ts
@src/tools/health-check.ts
@src/services/health-check.ts
@package.json
@README.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite README.md with npx-first structure</name>
  <files>README.md</files>
  <action>
Completely rewrite README.md following this exact section order (from research):

1. **Title + one-line description** -- "cc-bridge-mcp-server" + "MCP server for inter-Claude-Code session communication bridge"

2. **Quick Start** -- Two steps only:
   - Step 1: Add `.mcp.json` to BOTH project repos (show full copy-paste JSON with npx command, using `-y` flag):
     ```json
     {
       "mcpServers": {
         "cc-bridge": {
           "command": "npx",
           "args": ["-y", "cc-bridge-mcp-server"],
           "env": {}
         }
       }
     }
     ```
   - Alternative: `claude mcp add --transport stdio cc-bridge -- npx -y cc-bridge-mcp-server`
   - Step 2: Restart Claude Code in both repos. The bridge tools are now available.

3. **What It Does** -- Keep the existing Problem and Architecture sections but update the diagram to show `~/cloud_code_bridge/cc-bridge-state.json` (NOT `/tmp`). Keep the architecture explanation concise.

4. **Tools Reference** -- Document all 6 tools with parameters:
   - cc_register_peer (peerId, sessionId, cwd, label)
   - cc_deregister_peer (peerId)
   - cc_send_message (fromPeerId, toPeerId, message)
   - cc_list_peers (no params, mention potentiallyStale field)
   - cc_get_history (peerId optional, limit optional default 50)
   - cc_health_check (no params -- document all three checks: state file, lock mechanism, Claude CLI; document response fields: healthy, serverVersion, statePath, claudePath, checks, timestamp)

5. **Configuration** -- Environment variables table with ALL 6 vars. Verify each against src/config.ts:
   | Variable | Default | Description |
   |----------|---------|-------------|
   | CC_BRIDGE_STATE_PATH | ~/cloud_code_bridge | Directory for state file and logs |
   | CC_BRIDGE_TIMEOUT_MS | 120000 (2 min) | CLI subprocess timeout in milliseconds |
   | CC_BRIDGE_CHAR_LIMIT | 0 (unlimited) | Max characters in relayed message (0 = no limit) |
   | CC_BRIDGE_LOG_LEVEL | info | Log verbosity: debug, info, warn, error |
   | CC_BRIDGE_CLAUDE_PATH | claude | Path to the Claude Code CLI executable |
   | CC_BRIDGE_STALE_TIMEOUT_MS | 1800000 (30 min) | Idle time before peer flagged stale (0 = disabled) |

   Show env override example in .mcp.json:
   ```json
   {
     "mcpServers": {
       "cc-bridge": {
         "command": "npx",
         "args": ["-y", "cc-bridge-mcp-server"],
         "env": {
           "CC_BRIDGE_STATE_PATH": "/custom/path",
           "CC_BRIDGE_LOG_LEVEL": "debug"
         }
       }
     }
   }
   ```

6. **Usage Workflow** -- Keep the existing step-by-step but clean it up. Show the register-both-peers, send-message, get-history flow.

7. **Troubleshooting** -- Three subsections:
   a. NVM/PATH issues with three solutions (absolute npx path, claude mcp add, NVM in .zshrc/.bashrc)
   b. State file location (~/cloud_code_bridge/cc-bridge-state.json, override with CC_BRIDGE_STATE_PATH, logs at <state-path>/logs/)
   c. Common errors table:
   | Error | Cause | Fix |
   |-------|-------|-----|
   | CLI_NOT_FOUND | claude not on PATH | Install Claude Code or set CC_BRIDGE_CLAUDE_PATH |
   | CLI_TIMEOUT | Response took > 2 min | Increase CC_BRIDGE_TIMEOUT_MS |
   | LOCK_TIMEOUT | Lock held by dead process | Delete <state-path>/cc-bridge-state.json.lock |
   | STATE_CORRUPT | Invalid JSON in state | Auto-recovers; backup saved as .corrupt.<timestamp> |
   | PEER_NOT_FOUND | Target peer not registered | Register both peers before sending messages |

8. **Development** -- Build from source instructions (npm install, npm run build, npm test). Include the project structure tree (updated to include services/health-check.ts, tools/health-check.ts, config.ts, errors.ts, logger.ts, startup.ts). Include npm scripts table.

9. **License** -- "ISC" one-liner.

IMPORTANT: Do NOT reference /tmp anywhere. All state paths use ~/cloud_code_bridge. Do NOT include the old Constants table (those are now configurable env vars). Do NOT include the old Shared State JSON example (it is an implementation detail). Keep the README focused on user experience, not internals.
  </action>
  <verify>
Verify README.md contains required sections:
- grep "npx" README.md (should find npx installation commands)
- grep "CC_BRIDGE_STATE_PATH" README.md (env vars documented)
- grep "cc_health_check" README.md (health check documented)
- grep "Troubleshooting" README.md (troubleshooting section exists)
- grep "/tmp" README.md (should find NOTHING -- old path removed)
- grep "cloud_code_bridge" README.md (new default path referenced)
  </verify>
  <done>
README.md is a complete, npx-first user guide with: Quick Start (.mcp.json copy-paste), all 6 tools documented, all 6 env vars in a table, troubleshooting section with NVM/PATH solutions and error code table, development section with updated project structure. No references to /tmp or building from source as primary installation method.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create server.json and add mcpName to package.json</name>
  <files>server.json, package.json</files>
  <action>
1. Create server.json in the project root with MCP Registry metadata. Use the exact structure from research, with OWNER placeholder (user must provide GitHub username before publishing -- this is handled in Plan 02):

```json
{
  "$schema": "https://static.modelcontextprotocol.io/schemas/2025-12-11/server.schema.json",
  "name": "io.github.OWNER/cc-bridge-mcp-server",
  "title": "CC Bridge MCP Server",
  "description": "MCP server for inter-Claude-Code session communication bridge. Enables two Claude Code instances to collaborate across repositories by relaying messages via CLI subprocess calls.",
  "version": "0.1.0",
  "repository": {
    "url": "https://github.com/OWNER/cc-bridge-mcp-server",
    "source": "github"
  },
  "packages": [
    {
      "registryType": "npm",
      "identifier": "cc-bridge-mcp-server",
      "version": "0.1.0",
      "runtimeHint": "npx",
      "transport": {
        "type": "stdio"
      },
      "environmentVariables": [
        {
          "name": "CC_BRIDGE_STATE_PATH",
          "description": "Directory for state file and logs",
          "default": "~/cloud_code_bridge",
          "isRequired": false
        },
        {
          "name": "CC_BRIDGE_TIMEOUT_MS",
          "description": "CLI subprocess timeout in milliseconds",
          "default": "120000",
          "isRequired": false
        },
        {
          "name": "CC_BRIDGE_CHAR_LIMIT",
          "description": "Max characters in CLI message (0 = unlimited)",
          "default": "0",
          "isRequired": false
        },
        {
          "name": "CC_BRIDGE_LOG_LEVEL",
          "description": "Log verbosity: debug, info, warn, error",
          "default": "info",
          "isRequired": false
        },
        {
          "name": "CC_BRIDGE_CLAUDE_PATH",
          "description": "Path to the claude CLI executable",
          "default": "claude",
          "isRequired": false
        },
        {
          "name": "CC_BRIDGE_STALE_TIMEOUT_MS",
          "description": "Time in ms before a peer is flagged as stale (0 = disabled)",
          "default": "1800000",
          "isRequired": false
        }
      ]
    }
  ]
}
```

2. Add mcpName field to package.json. Read package.json first, then add the field after "license":
   ```json
   "mcpName": "io.github.OWNER/cc-bridge-mcp-server"
   ```
   The mcpName value MUST match the "name" field in server.json exactly.

3. Verify version consistency: package.json version (0.1.0) must match server.json version (0.1.0) and server.json packages[0].version (0.1.0).
  </action>
  <verify>
- cat server.json | node -e "const j=JSON.parse(require('fs').readFileSync('/dev/stdin','utf8')); console.log('valid JSON'); console.log('version:', j.version); console.log('name:', j.name)"
- node -e "const p=require('./package.json'); console.log('mcpName:', p.mcpName); console.log('version:', p.version)"
- Verify mcpName in package.json matches name in server.json
- Verify version 0.1.0 appears in both files
  </verify>
  <done>
server.json exists with valid MCP Registry schema, all 6 environment variables, and OWNER placeholder. package.json has mcpName field matching server.json name. Version 0.1.0 is consistent across both files.
  </done>
</task>

</tasks>

<verification>
1. README.md contains "npx" in Quick Start section
2. README.md documents all 6 CC_BRIDGE_* env vars in a table
3. README.md documents all 6 tools including cc_health_check
4. README.md has Troubleshooting section with NVM/PATH, state location, error codes
5. README.md does NOT reference /tmp as state path
6. server.json is valid JSON matching MCP Registry schema
7. package.json contains mcpName matching server.json name
8. Version 0.1.0 is consistent across package.json and server.json
</verification>

<success_criteria>
- A user reading only the README can: install via npx, configure via .mcp.json, understand all tools, configure env vars, and troubleshoot common issues
- server.json is ready for MCP Registry submission (pending OWNER replacement)
- package.json has mcpName for registry ownership verification
</success_criteria>

<output>
After completion, create `.planning/phases/05-documentation-and-registry/05-01-SUMMARY.md`
</output>
