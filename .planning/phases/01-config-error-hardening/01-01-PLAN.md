---
phase: 01-config-error-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/config.ts
  - src/errors.ts
  - src/constants.ts
autonomous: true

must_haves:
  truths:
    - "Setting CC_BRIDGE_STATE_PATH env var changes where the server reads/writes state"
    - "Setting CC_BRIDGE_TIMEOUT_MS or CC_BRIDGE_CHAR_LIMIT changes CLI behavior"
    - "Invalid config values (negative timeout, non-numeric string) produce clear error at startup"
    - "All error codes are machine-readable with descriptive messages and fix suggestions"
  artifacts:
    - path: "src/config.ts"
      provides: "Zod-validated config singleton with env var parsing"
      exports: ["loadConfig", "getConfig", "resetConfig", "Config"]
      contains: "z.coerce"
    - path: "src/errors.ts"
      provides: "BridgeError class and error code enum"
      exports: ["BridgeError", "BridgeErrorCode", "toolResult", "errorResult"]
      contains: "BridgeErrorCode"
    - path: "src/constants.ts"
      provides: "Server name/version constants, re-exports config"
      exports: ["SERVER_NAME", "SERVER_VERSION"]
  key_links:
    - from: "src/config.ts"
      to: "process.env"
      via: "Zod safeParse"
      pattern: "configSchema\\.safeParse"
    - from: "src/errors.ts"
      to: "src/config.ts"
      via: "imports not required (standalone)"
      pattern: "BridgeErrorCode"
---

<objective>
Create the configuration and error foundations that every other plan depends on.

Purpose: Config.ts is the single source of truth for all runtime settings (paths, timeouts, log level). Errors.ts defines the structured error system (codes + messages + suggestions). Constants.ts is refactored to stop hardcoding values. These are the bedrock modules -- nothing else can be built without them.

Output: Three files providing typed config, structured errors, and utility functions for MCP error responses.
</objective>

<execution_context>
@/Users/dev/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-config-error-hardening/01-CONTEXT.md
@.planning/phases/01-config-error-hardening/01-RESEARCH.md
@src/constants.ts
@src/types.ts
@package.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create config.ts with Zod-validated env var parsing</name>
  <files>src/config.ts</files>
  <action>
Create `src/config.ts` with:

1. Import `z` from "zod", `os` from "node:os", `path` from "node:path".

2. Define `defaultStatePath` as `path.join(os.homedir(), "cloud_code_bridge")` -- per user decision (NOT os.tmpdir()).

3. Define `configSchema` as a Zod object with these fields:
   - `CC_BRIDGE_STATE_PATH`: `z.string().default(defaultStatePath)` -- path to state directory
   - `CC_BRIDGE_TIMEOUT_MS`: `z.coerce.number().int().min(1000).default(120_000)` -- CLI subprocess timeout
   - `CC_BRIDGE_CHAR_LIMIT`: `z.coerce.number().int().min(0).default(0)` -- 0 means no limit, per user decision (NOT 25000)
   - `CC_BRIDGE_LOG_LEVEL`: `z.enum(["debug", "info", "warn", "error"]).default("info")` -- per discretion recommendation
   - `CC_BRIDGE_CLAUDE_PATH`: `z.string().default("claude")` -- path to claude binary

4. Export `type Config = z.infer<typeof configSchema>`.

5. Implement singleton pattern with three exported functions:
   - `loadConfig(env?: Record<string, string | undefined>)`: Parses env through Zod schema using `safeParse`. On failure, formats Zod issues into readable error messages showing which env var is invalid and why. Returns frozen config object. Default arg is `process.env`.
   - `getConfig()`: Returns cached config or throws "Config not loaded" error.
   - `resetConfig()`: Sets singleton to null (for testing only).

6. Also export the raw `configSchema` for testing purposes.

Key details:
- Use flat CC_BRIDGE_* prefix (per discretion recommendation -- no config file for v1).
- The loadConfig function accepts an optional env param so tests can inject values without touching process.env.
- Object.freeze the parsed result to prevent accidental mutation.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Verify the file exports loadConfig, getConfig, resetConfig, and Config type by checking the compiled output.
  </verify>
  <done>
config.ts exists, exports a Zod-validated config singleton. Default state path is ~/cloud_code_bridge. Default char limit is 0. Default timeout is 120000. Default log level is "info". Invalid env values produce clear Zod error messages. Config object is frozen after loading.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create errors.ts with BridgeError class and MCP response utilities</name>
  <files>src/errors.ts</files>
  <action>
Create `src/errors.ts` with:

1. Define `BridgeErrorCode` enum with these string values:
   - `CLI_NOT_FOUND` -- claude binary not on PATH
   - `CLI_TIMEOUT` -- subprocess exceeded timeout
   - `CLI_EXEC_FAILED` -- subprocess returned non-zero exit
   - `STATE_CORRUPT` -- state file JSON parse failed
   - `STATE_WRITE_FAILED` -- could not write state file
   - `LOCK_TIMEOUT` -- failed to acquire file lock within timeout
   - `LOCK_STALE` -- detected and cleaned up stale lock
   - `PEER_NOT_FOUND` -- requested peer not registered
   - `INVALID_INPUT` -- tool input validation failed
   - `STARTUP_FAILED` -- startup validation failed
   - `DIR_NOT_WRITABLE` -- state directory not writable

2. Define `BridgeError extends Error` class with:
   - Constructor params: `code: BridgeErrorCode`, `message: string`, optional `suggestion?: string`
   - `this.name = "BridgeError"`
   - Message format: `${code}: ${message}` -- append `. ${suggestion}` if suggestion provided
   - Public readonly `code` and `suggestion` properties

3. Define utility functions for MCP tool responses:
   - `toolResult(text: string, isError?: boolean)`: Returns `{ content: [{ type: "text", text }], ...(isError ? { isError: true } : {}) }`. This replaces the repetitive JSON response pattern in every tool handler.
   - `errorResult(error: unknown)`: If error is BridgeError, returns toolResult with JSON `{ success: false, error: code, message, suggestion }` and isError true. If generic Error, returns toolResult with `{ success: false, error: "INTERNAL_ERROR", message }` and isError true. This is the universal catch handler for tool implementations.
   - `successResult(data: Record<string, unknown>)`: Returns toolResult with JSON.stringify(data, null, 2) and isError false. Convenience for the happy path.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors. Verify BridgeError instances produce the correct message format: "CLI_TIMEOUT: CLI timed out after 30000ms. Increase CC_BRIDGE_TIMEOUT_MS if needed".
  </verify>
  <done>
errors.ts exists with BridgeErrorCode enum (11 codes), BridgeError class with code+message+suggestion, and three utility functions (toolResult, errorResult, successResult) that standardize MCP tool responses.
  </done>
</task>

<task type="auto">
  <name>Task 3: Refactor constants.ts to use config exports</name>
  <files>src/constants.ts</files>
  <action>
Modify `src/constants.ts`:

1. Keep `SERVER_NAME` and `SERVER_VERSION` as direct exports (these are compile-time constants, not configurable).
2. Remove the hardcoded `CHARACTER_LIMIT = 25_000` and `CLI_TIMEOUT_MS = 120_000` lines entirely.
3. Do NOT re-export config values from here -- modules that need config should import from config.ts directly. This avoids circular dependency issues and makes the dependency explicit.

The file should be minimal after this change -- just the two server identity constants. Modules currently importing CHARACTER_LIMIT and CLI_TIMEOUT_MS from constants.ts will be updated in later plans to import from config.ts instead.

Note: This intentionally creates temporary TypeScript errors in cc-cli.ts (which imports CHARACTER_LIMIT and CLI_TIMEOUT_MS from constants). Those will be resolved in Plan 03 when cc-cli.ts is rewritten to use config.ts.
  </action>
  <verify>
Run `npx tsc --noEmit 2>&1 | head -20` -- expect errors ONLY in `src/services/cc-cli.ts` about missing CHARACTER_LIMIT and CLI_TIMEOUT_MS imports. No errors in any other file means constants.ts is correct and other modules are unaffected.
  </verify>
  <done>
constants.ts contains only SERVER_NAME and SERVER_VERSION. Hardcoded CHARACTER_LIMIT and CLI_TIMEOUT_MS are removed. The only downstream breakage is in cc-cli.ts (fixed in Plan 03).
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` produces errors ONLY in cc-cli.ts (expected, fixed in Plan 03)
2. `node -e "const c = require('./dist/config.js'); console.log(c)"` -- after build, config module exports loadConfig, getConfig, resetConfig
3. Config default state path includes "cloud_code_bridge" and uses os.homedir() (not tmpdir)
4. Config default char limit is 0 (not 25000)
5. BridgeError with code CLI_TIMEOUT produces message starting with "CLI_TIMEOUT:"
</verification>

<success_criteria>
- config.ts parses all 5 CC_BRIDGE_* env vars with Zod coercion and correct defaults
- errors.ts defines 11 error codes, BridgeError class, and 3 MCP response utilities
- constants.ts only has SERVER_NAME and SERVER_VERSION
- No type errors except expected ones in cc-cli.ts
</success_criteria>

<output>
After completion, create `.planning/phases/01-config-error-hardening/01-01-SUMMARY.md`
</output>
