---
phase: 01-config-error-hardening
plan: 04
type: execute
wave: 3
depends_on: ["01-02", "01-03"]
files_modified:
  - src/tools/register-peer.ts
  - src/tools/deregister-peer.ts
  - src/tools/send-message.ts
  - src/tools/list-peers.ts
  - src/tools/get-history.ts
autonomous: true

must_haves:
  truths:
    - "Every tool handler catches exceptions and returns structured MCP error responses instead of crashing"
    - "Tool error responses include machine-readable error code, descriptive message, and fix suggestion"
    - "Tool success responses use consistent JSON format via successResult utility"
    - "No unhandled promise rejection can originate from a tool handler"
    - "The send-message catch block's recordMessage call has its own error handling"
  artifacts:
    - path: "src/tools/register-peer.ts"
      provides: "Error-wrapped peer registration tool"
      contains: "errorResult"
    - path: "src/tools/deregister-peer.ts"
      provides: "Error-wrapped peer deregistration tool"
      contains: "errorResult"
    - path: "src/tools/send-message.ts"
      provides: "Error-wrapped message sending tool"
      contains: "errorResult"
    - path: "src/tools/list-peers.ts"
      provides: "Error-wrapped peer listing tool"
      contains: "errorResult"
    - path: "src/tools/get-history.ts"
      provides: "Error-wrapped history retrieval tool"
      contains: "errorResult"
  key_links:
    - from: "src/tools/*.ts"
      to: "src/errors.ts"
      via: "import errorResult and successResult utilities"
      pattern: "errorResult|successResult"
    - from: "src/tools/send-message.ts"
      to: "src/services/cc-cli.ts"
      via: "enriched CLI errors flow through to tool response"
      pattern: "execClaude"
---

<objective>
Wrap all 5 tool handlers with structured error handling using the error utilities from Plan 01.

Purpose: Currently, tool handlers have inconsistent error handling. register-peer has no try/catch at all. send-message has try/catch but the catch block's recordMessage call could itself throw (nested unhandled rejection). All handlers use verbose inline JSON response construction. This plan replaces all of that with the standardized errorResult/successResult utilities and ensures every handler has a top-level try/catch that prevents any exception from crashing the MCP connection.

Output: Five modified tool handler files, all using consistent error formatting and bulletproof exception handling.
</objective>

<execution_context>
@/Users/dev/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-config-error-hardening/01-CONTEXT.md
@.planning/phases/01-config-error-hardening/01-RESEARCH.md
@.planning/phases/01-config-error-hardening/01-01-SUMMARY.md
@.planning/phases/01-config-error-hardening/01-03-SUMMARY.md
@src/tools/register-peer.ts
@src/tools/deregister-peer.ts
@src/tools/send-message.ts
@src/tools/list-peers.ts
@src/tools/get-history.ts
@src/errors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wrap register-peer, deregister-peer, and list-peers with error handling</name>
  <files>src/tools/register-peer.ts, src/tools/deregister-peer.ts, src/tools/list-peers.ts</files>
  <action>
Update three simpler tool handlers to use the standardized error utilities:

**register-peer.ts:**
1. Add import: `successResult`, `errorResult` from errors.ts. Add `logger` from logger.ts.
2. Wrap the entire handler body in try/catch.
3. Replace the inline JSON response with `successResult({ success: true, action: existing ? "updated" : "registered", peer })`.
4. Catch block: `logger.error("register-peer failed", { error: err }); return errorResult(err);`

**deregister-peer.ts:**
1. Add import: `successResult`, `errorResult` from errors.ts. Add `logger` from logger.ts.
2. Wrap the entire handler body in try/catch.
3. Replace the inline JSON response with `successResult({ success: removed, message: removed ? "Peer '{peerId}' deregistered" : "Peer '{peerId}' was not registered" })`.
4. Catch block: `logger.error("deregister-peer failed", { error: err }); return errorResult(err);`

**list-peers.ts:**
1. Add import: `successResult`, `errorResult` from errors.ts. Add `logger` from logger.ts.
2. Wrap the entire handler body in try/catch.
3. Replace the inline JSON response with `successResult({ peers, count: peers.length })`.
4. Catch block: `logger.error("list-peers failed", { error: err }); return errorResult(err);`

Key: Keep all existing tool registration metadata (title, description, inputSchema, annotations) unchanged. Only modify the handler function body.
  </action>
  <verify>
Run `npx tsc --noEmit` -- zero errors. Verify each handler has a top-level try/catch by searching for "catch" in each file. Verify errorResult import exists in each file.
  </verify>
  <done>
register-peer.ts, deregister-peer.ts, and list-peers.ts all have top-level try/catch, use successResult for happy path, errorResult for exceptions, and log errors via logger.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wrap send-message and get-history with error handling</name>
  <files>src/tools/send-message.ts, src/tools/get-history.ts</files>
  <action>
Update two remaining tool handlers:

**send-message.ts (most complex -- needs nested error handling):**
1. Add import: `successResult`, `errorResult` from errors.ts. Add `logger` from logger.ts.
2. Wrap the ENTIRE handler in an outer try/catch (including the peer lookups that currently lack one).
3. Replace the "sender not registered" / "target not registered" responses with `errorResult(new BridgeError(BridgeErrorCode.PEER_NOT_FOUND, "Sender peer '{fromPeerId}' not registered", "Register the peer first with cc_register_peer"))` and similar for target.
4. In the existing inner try block (after execClaude):
   - Replace the inline success response with `successResult({ success, response: success ? result.stdout : null, error: success ? null : result.stderr, durationMs })`.
5. In the existing inner catch block:
   - CRITICAL: Wrap the `recordMessage()` call in its own try/catch. Currently if recordMessage throws here, it becomes an unhandled rejection because the outer catch won't catch it (the inner catch re-throws or returns). Add: `try { await recordMessage({...}); } catch (recordErr) { logger.error("Failed to record failed message", { error: recordErr }); }` -- losing the audit record is better than crashing the server.
   - Return `errorResult(err)` after recording attempt.
6. The outer catch handles anything unexpected (peer lookup failures, etc.): `logger.error("send-message failed", { error: err }); return errorResult(err);`

**get-history.ts:**
1. Add import: `successResult`, `errorResult` from errors.ts. Add `logger` from logger.ts.
2. Wrap the entire handler body in try/catch.
3. Replace the inline JSON response with `successResult({ messages, count: messages.length })`.
4. Catch block: `logger.error("get-history failed", { error: err }); return errorResult(err);`

Key for send-message: The nested recordMessage in the catch path is the most dangerous unhandled rejection source in the entire codebase. It MUST have its own try/catch.
  </action>
  <verify>
Run `npx tsc --noEmit` -- zero errors. Run `npm run build` -- succeeds. Verify send-message.ts has TWO levels of try/catch (outer for handler, inner try/catch around recordMessage in the error path). Verify all 5 tool files import from errors.ts.
  </verify>
  <done>
send-message.ts has outer try/catch, uses BridgeError for peer-not-found, has nested try/catch around recordMessage in error path. get-history.ts has try/catch with errorResult. All 5 tool handlers now use consistent error formatting and cannot produce unhandled rejections.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` succeeds with zero errors
2. All 5 tool handlers import and use errorResult from errors.ts
3. All 5 tool handlers have top-level try/catch
4. send-message.ts recordMessage in catch block has its own try/catch
5. No tool handler uses inline `{ content: [{ type: "text", text: JSON.stringify(...) }] }` directly -- all use successResult/errorResult
6. Peer-not-found errors include BridgeErrorCode.PEER_NOT_FOUND and suggestion
7. `npx tsc --noEmit` zero errors
</verification>

<success_criteria>
- Every tool handler has a top-level try/catch returning errorResult
- Every success path uses successResult for consistent JSON formatting
- send-message nested recordMessage call has its own error handling
- Peer-not-found uses BridgeError with code and suggestion
- Full build succeeds, all TypeScript errors resolved
- No unhandled promise rejection can originate from any tool handler
</success_criteria>

<output>
After completion, create `.planning/phases/01-config-error-hardening/01-04-SUMMARY.md`
</output>
