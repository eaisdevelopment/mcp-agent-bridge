---
phase: 01-config-error-hardening
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/services/peer-registry.ts
  - src/services/cc-cli.ts
autonomous: true

must_haves:
  truths:
    - "Setting CC_BRIDGE_STATE_PATH causes peer-registry to read/write state at the custom path"
    - "Corrupting the state file JSON triggers auto-recovery: backup + fresh state + warning log"
    - "Lock acquisition timeout produces a clear error with the timeout value and PID of lock holder"
    - "CLI subprocess timeout produces error including the timeout value and suggestion to increase it"
    - "CLI subprocess failure includes exit code and stderr in the error response"
    - "Setting CC_BRIDGE_CHAR_LIMIT to a positive value truncates messages; 0 means no truncation"
    - "Setting CC_BRIDGE_CLAUDE_PATH uses the custom binary path instead of 'claude'"
  artifacts:
    - path: "src/services/peer-registry.ts"
      provides: "Config-driven state management with error recovery"
      exports: ["registerPeer", "deregisterPeer", "getPeer", "listPeers", "recordMessage", "getHistory"]
      contains: "BridgeError"
    - path: "src/services/cc-cli.ts"
      provides: "Config-driven CLI execution with enriched errors"
      exports: ["execClaude"]
      contains: "getConfig"
  key_links:
    - from: "src/services/peer-registry.ts"
      to: "src/config.ts"
      via: "getConfig() for state path"
      pattern: "getConfig\\(\\)"
    - from: "src/services/peer-registry.ts"
      to: "src/logger.ts"
      via: "logger for warnings on corrupt state"
      pattern: "logger\\.warn"
    - from: "src/services/cc-cli.ts"
      to: "src/config.ts"
      via: "getConfig() for timeout, char limit, claude path"
      pattern: "getConfig\\(\\)"
---

<objective>
Update the two service modules to use centralized config and structured error handling.

Purpose: peer-registry.ts currently hardcodes the state path to /tmp and has no error recovery for corrupt state. cc-cli.ts hardcodes timeout and character limit. Both need to read from config.ts, use BridgeError for structured errors, and add recovery/enrichment paths. These are the core services that all tool handlers depend on.

Output: Two modified service files that are fully configurable and produce clear, actionable errors.
</objective>

<execution_context>
@/Users/dev/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-config-error-hardening/01-CONTEXT.md
@.planning/phases/01-config-error-hardening/01-RESEARCH.md
@.planning/phases/01-config-error-hardening/01-01-SUMMARY.md
@src/services/peer-registry.ts
@src/services/cc-cli.ts
@src/config.ts
@src/errors.ts
@src/types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update peer-registry.ts with config-driven paths and error recovery</name>
  <files>src/services/peer-registry.ts</files>
  <action>
Modify `src/services/peer-registry.ts` to use config and add error recovery:

1. Add imports: `getConfig` from config.ts, `logger` from logger.ts, `BridgeError`, `BridgeErrorCode` from errors.ts.

2. Replace hardcoded constants:
   - Remove `const STATE_PATH = path.join("/tmp", "cc-bridge-state.json")`
   - Replace with a function: `function getStatePath() { return path.join(getConfig().CC_BRIDGE_STATE_PATH, "cc-bridge-state.json"); }`
   - Similarly for lock path: `function getLockPath() { return getStatePath() + ".lock"; }`
   - Keep `MAX_MESSAGES = 500`, `LOCK_RETRY_MS = 50`, `LOCK_MAX_WAIT_MS = 5_000` as module-level constants (these are internal tuning, not user-configurable).

3. Update `readState()` to handle corrupt JSON -- per user decision on auto-recovery:
   - On `SyntaxError` (corrupt JSON):
     a. Create backup: `statePath + ".corrupt." + Date.now()`
     b. Copy corrupt file to backup using `fs.copyFile()` (wrap in catch -- backup failure is non-fatal)
     c. Log warning: `"STATE_CORRUPT: State file corrupt (invalid JSON), backed up to {backupPath}. Starting with empty state."`
     d. Return `emptyState()`
   - On `ENOENT`: Return emptyState() (unchanged from current behavior)
   - On other errors: throw as BridgeError(STATE_WRITE_FAILED, message)

4. Update `writeState()` to use config-driven path:
   - Replace hardcoded STATE_PATH with `getStatePath()`
   - Wrap in try/catch, throw BridgeError(STATE_WRITE_FAILED, ...) on failure

5. Update `acquireLock()`:
   - Use `getLockPath()`
   - On timeout, read the lock file to get the PID of the holder
   - Throw `BridgeError(BridgeErrorCode.LOCK_TIMEOUT, "Failed to acquire lock within ${LOCK_MAX_WAIT_MS}ms (held by PID ${lockPid})", "Another cc-bridge process may be stuck. Delete ${lockPath} if no other instance is running.")`
   - On stale lock cleanup: log info "Cleaned up stale lock from PID {pid}"

6. Update all public functions (registerPeer, deregisterPeer, getPeer, listPeers, recordMessage, getHistory) to use the dynamic path functions.

7. Keep the existing withLock pattern, atomic write-via-rename pattern, and stale lock detection logic -- these are correct. Only add error enrichment on top.

Key: The state file path and lock file path are now derived from config at call time (not module load time), so tests can use resetConfig() + loadConfig() to change paths between test runs.
  </action>
  <verify>
Run `npx tsc --noEmit` to confirm no type errors in peer-registry.ts (cc-cli.ts errors are resolved in Task 2). Verify that no hardcoded "/tmp" references remain. Verify that readState() has a SyntaxError catch branch.
  </verify>
  <done>
peer-registry.ts reads state path from config (not hardcoded /tmp). Corrupt state triggers auto-recovery with backup file + warning log. Lock timeout includes PID and timeout value. All state operations use BridgeError for structured errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update cc-cli.ts with config-driven settings and enriched errors</name>
  <files>src/services/cc-cli.ts</files>
  <action>
Modify `src/services/cc-cli.ts` to use config and enrich errors:

1. Replace imports: Remove `CLI_TIMEOUT_MS, CHARACTER_LIMIT` from constants.ts. Add `getConfig` from config.ts.

2. Update `execClaude()` function:
   a. Read config at call time: `const config = getConfig();`
   b. Character limit: If `config.CC_BRIDGE_CHAR_LIMIT > 0`, truncate message. If `config.CC_BRIDGE_CHAR_LIMIT === 0`, do NOT truncate (no limit per user decision). Current code always truncates at 25000 -- change to conditional.
   c. Claude binary: Use `config.CC_BRIDGE_CLAUDE_PATH` instead of hardcoded `"claude"` string in the execFile call.
   d. Timeout: Use `config.CC_BRIDGE_TIMEOUT_MS` instead of the removed constant.

3. Enrich error handling in the execFile callback:
   - Detect timeout specifically: If `error.killed === true` and the error signal is SIGTERM, this indicates timeout. Set `stderr` to: `"CLI_TIMEOUT: CLI subprocess timed out after ${config.CC_BRIDGE_TIMEOUT_MS}ms. Increase CC_BRIDGE_TIMEOUT_MS if needed."` -- per user decision on timeout error format.
   - Detect missing binary: If `error.code === "ENOENT"`, set stderr to: `"CLI_NOT_FOUND: '${config.CC_BRIDGE_CLAUDE_PATH}' not found. Install Claude Code or set CC_BRIDGE_CLAUDE_PATH."` -- per user decision on error format.
   - For other errors: Include the exit code in the error message: `"CLI_EXEC_FAILED: claude exited with code ${exitCode}. stderr: ${stderr}"`.

4. Keep the CliExecResult return type unchanged -- the tool handler in send-message.ts already reads exitCode, stdout, stderr from it. The enrichment goes into the stderr field so the tool handler's error response includes the actionable message.

5. Keep the maxBuffer at 10MB and the env passthrough (`{ ...process.env }`).

Key: The function signature does not change. Callers still get CliExecResult. The enrichment is in the error messaging within the result, not in thrown exceptions.
  </action>
  <verify>
Run `npx tsc --noEmit` -- should now compile cleanly (no more missing imports from constants.ts). Verify that no references to CHARACTER_LIMIT or CLI_TIMEOUT_MS from constants.ts remain. Verify that the claude binary path comes from config.
  </verify>
  <done>
cc-cli.ts reads timeout, char limit, and claude path from config. Char limit of 0 means no truncation. Timeout errors include the ms value and suggestion. Missing binary errors include the path and fix suggestion. No hardcoded constants remain.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` compiles with zero errors (all constant imports resolved)
2. `npm run build` succeeds
3. No hardcoded "/tmp" in peer-registry.ts (grep confirms)
4. No `CHARACTER_LIMIT` or `CLI_TIMEOUT_MS` imported from constants.ts anywhere
5. Corrupt state recovery path creates backup file with ".corrupt.{timestamp}" suffix
6. Lock timeout error includes PID and ms value
7. CLI timeout error includes ms value and CC_BRIDGE_TIMEOUT_MS suggestion
</verification>

<success_criteria>
- peer-registry.ts state path is config-driven (~/cloud_code_bridge by default)
- Corrupt state auto-recovers with backup + warning
- Lock errors include PID and timeout value
- cc-cli.ts timeout, char limit, and binary path are all config-driven
- Char limit 0 = no truncation
- CLI errors include actionable fix suggestions
- Full TypeScript compilation succeeds with zero errors
</success_criteria>

<output>
After completion, create `.planning/phases/01-config-error-hardening/01-03-SUMMARY.md`
</output>
