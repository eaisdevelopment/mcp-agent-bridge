---
phase: 01-config-error-hardening
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/logger.ts
  - src/startup.ts
  - src/index.ts
autonomous: true

must_haves:
  truths:
    - "Setting CC_BRIDGE_LOG_LEVEL=debug produces verbose stderr output and verbose log files"
    - "Setting CC_BRIDGE_LOG_LEVEL=error suppresses info/warn on stderr and in log files"
    - "Stdout remains clean (no log output) in all log level configurations"
    - "Log files are created in the state directory under a logs/ subfolder"
    - "Starting the server without claude on PATH produces a clear startup warning on stderr"
    - "State directory is auto-created if it does not exist"
    - "Non-writable state directory produces a clear error at startup"
    - "First run with TTY prompts user for state directory; non-TTY uses defaults silently"
  artifacts:
    - path: "src/logger.ts"
      provides: "Dual-output logger (stderr + text file + JSON file)"
      exports: ["Logger", "createLogger", "logger"]
      contains: "WriteStream"
    - path: "src/startup.ts"
      provides: "First-run setup, startup validation, config persistence"
      exports: ["runStartup"]
      contains: "isTTY"
    - path: "src/index.ts"
      provides: "Server entry point with startup flow and global error handlers"
      contains: "unhandledRejection"
  key_links:
    - from: "src/logger.ts"
      to: "src/config.ts"
      via: "imports getConfig for log level and state path"
      pattern: "getConfig"
    - from: "src/startup.ts"
      to: "src/config.ts"
      via: "imports loadConfig to initialize configuration"
      pattern: "loadConfig"
    - from: "src/startup.ts"
      to: "src/logger.ts"
      via: "uses logger for startup messages"
      pattern: "logger\\."
    - from: "src/index.ts"
      to: "src/startup.ts"
      via: "calls runStartup before server.connect"
      pattern: "runStartup"
---

<objective>
Create the logging system, startup validation flow, and rewire the server entry point.

Purpose: The logger implements the user's dual-logging requirement (text file + JSON file + stderr). The startup module handles first-run detection, interactive prompts, directory creation, write validation, and claude CLI detection. The index.ts rewrite wires startup before MCP transport and adds global error handlers. Together these ensure the server starts safely, logs properly, and never crashes from unhandled errors.

Output: Three files providing the complete server lifecycle from startup validation through runtime logging to graceful error handling.
</objective>

<execution_context>
@/Users/dev/.claude/get-shit-done/workflows/execute-plan.md
@/Users/dev/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-config-error-hardening/01-CONTEXT.md
@.planning/phases/01-config-error-hardening/01-RESEARCH.md
@.planning/phases/01-config-error-hardening/01-01-SUMMARY.md
@src/index.ts
@src/config.ts
@src/errors.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create logger.ts with dual-output logging</name>
  <files>src/logger.ts</files>
  <action>
Create `src/logger.ts` implementing the user's dual-logging requirement:

1. Define `LogLevel` type: `"debug" | "info" | "warn" | "error"`.
2. Define `LEVELS` record mapping each level to a numeric priority: debug=0, info=1, warn=2, error=3.

3. Define `Logger` class with:
   - Constructor params: `level: LogLevel`, optional `logDir?: string`
   - If logDir provided:
     - Create logDir with `fs.mkdirSync(logDir, { recursive: true })`
     - Create timestamped log filenames using server start time (e.g., `bridge-2026-02-09T12-00-00.log` and `bridge-2026-02-09T12-00-00.json.log`) -- per research recommendation to avoid rotation complexity
     - Open two `fs.createWriteStream` instances with `{ flags: "a" }` for text and JSON
   - Private `log(level, message, data?)` method that:
     - Checks `LEVELS[level] >= this.level` -- skip if below threshold
     - Creates ISO timestamp
     - Writes to stderr: `${timestamp} [${level.toUpperCase()}] ${message}\n` using `process.stderr.write()`
     - Writes to text stream (if open): same human-readable format
     - Writes to JSON stream (if open): `JSON.stringify({ timestamp, level, message, ...(data ? { data } : {}) }) + "\n"`
   - Public methods: `debug(msg, data?)`, `info(msg, data?)`, `warn(msg, data?)`, `error(msg, data?)`
   - Public `close()` method: calls `.end()` on both streams

4. Export a `createLogger(level: LogLevel, logDir?: string): Logger` factory function.

5. Export a mutable module-level `logger` variable initialized to a default Logger("info") with no log dir. This is the "pre-config" logger that writes to stderr only. After startup, it gets replaced with the fully-configured logger via an exported `initLogger(level, logDir)` function that creates a new Logger and assigns it to the module-level export.

Key: All output goes to stderr, text file, and JSON file. NEVER to stdout (breaks MCP stdio transport). The startup banner ("server running on stdio") should always print regardless of log level -- handle this in index.ts by writing directly to stderr, not through the logger.
  </action>
  <verify>
Run `npx tsc --noEmit` (ignoring cc-cli.ts errors from Plan 01). Verify the logger class compiles cleanly. Manually verify no `process.stdout` references exist in logger.ts.
  </verify>
  <done>
logger.ts exists with dual-output Logger class. Writes to stderr + text file + JSON file. Respects log level filtering. Never touches stdout. Exports createLogger, initLogger, logger, and Logger.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create startup.ts with first-run setup and validation</name>
  <files>src/startup.ts</files>
  <action>
Create `src/startup.ts` implementing startup validation and first-run interactive setup:

1. Import: `loadConfig`, `getConfig` from config.ts; `initLogger`, `logger` from logger.ts; `BridgeError`, `BridgeErrorCode` from errors.ts; `readline` from "node:readline"; `fs` from "node:fs/promises"; `path` from "node:path"; `execFile` from "node:child_process"; `promisify` from "node:util".

2. Define config persistence path: `path.join(os.homedir(), ".cc-bridge-config.json")` -- per research recommendation for first-run persistence.

3. Implement `loadPersistedConfig()`: Try to read and parse ~/.cc-bridge-config.json. Return `{ statePath?: string }` or empty object on failure. This provides the user's previous first-run choice.

4. Implement `savePersistedConfig(config: { statePath: string })`: Write to ~/.cc-bridge-config.json. Wrap in try/catch, log warning on failure (non-fatal).

5. Implement `firstRunPrompt(defaultPath: string): Promise<string>`:
   - If `!process.stdin.isTTY`, return defaultPath silently (MCP host context).
   - Check if ~/.cc-bridge-config.json exists -- if so, this is NOT first run, return the persisted statePath (or defaultPath if missing).
   - Create readline interface with `input: process.stdin, output: process.stderr` (CRITICAL: output to stderr, not stdout).
   - Prompt: "First run detected. Where should cc-bridge store its data?\n  Default: {defaultPath}\n  Press Enter to accept, or type a custom path: "
   - On answer: trim, use defaultPath if empty, save choice to persist file, close readline, return chosen path.

6. Implement `validateStateDir(statePath: string)`:
   - Create directory with `fs.mkdir(statePath, { recursive: true })`.
   - Test write access by creating and deleting a `.write-test` file.
   - On failure: throw BridgeError(STARTUP_FAILED, "Cannot write to state directory: {path}", "Check permissions or set CC_BRIDGE_STATE_PATH to a writable directory").

7. Implement `checkClaudeCli(claudePath: string)`:
   - Use promisified execFile to run `{claudePath} --version` with 5s timeout.
   - On success: log info with detected version.
   - On failure: log warn with message: "CLI_NOT_FOUND: '{claudePath}' not found on PATH. cc_send_message will fail until Claude Code is installed. Set CC_BRIDGE_CLAUDE_PATH if installed in a non-standard location." -- per user decision on error format. Do NOT throw (warn-and-continue per discretion).

8. Export `async function runStartup(): Promise<void>`:
   a. Determine state path: first check env var CC_BRIDGE_STATE_PATH. If set, use it directly. If not set, call firstRunPrompt with the OS default.
   b. Construct final env overrides: if firstRunPrompt returned a different path, set it in the env for loadConfig.
   c. Call `loadConfig()` with the final environment.
   d. Get config via `getConfig()`.
   e. Call `initLogger(config.CC_BRIDGE_LOG_LEVEL, path.join(config.CC_BRIDGE_STATE_PATH, "logs"))` to initialize the full logger.
   f. Call `validateStateDir(config.CC_BRIDGE_STATE_PATH)`.
   g. Call `checkClaudeCli(config.CC_BRIDGE_CLAUDE_PATH)`.
   h. Log info: "Startup complete. State: {statePath}, Log level: {level}".
  </action>
  <verify>
Run `npx tsc --noEmit` (ignoring cc-cli.ts errors). Verify startup.ts compiles. Check that readline output goes to stderr (search for `output: process.stderr` in the code). Check that no stdout writes exist.
  </verify>
  <done>
startup.ts exists with runStartup() that: detects first run and prompts via TTY, persists choice to ~/.cc-bridge-config.json, creates state dir with parents, validates write access, checks claude CLI (warn-only), initializes logger. Interactive prompt uses stderr for output. Non-TTY mode uses defaults silently.
  </done>
</task>

<task type="auto">
  <name>Task 3: Rewrite index.ts with startup flow and global error handlers</name>
  <files>src/index.ts</files>
  <action>
Rewrite `src/index.ts` to integrate the startup and error handling systems:

1. Imports:
   - `McpServer` from SDK
   - `StdioServerTransport` from SDK
   - `SERVER_NAME, SERVER_VERSION` from constants.ts
   - `runStartup` from startup.ts
   - `logger` from logger.ts
   - `getConfig` from config.ts

2. Register global error handlers FIRST (before anything else):
   ```
   process.on("uncaughtException", (err) => {
     logger.error(`Uncaught exception: ${err.message}`, { stack: err.stack });
     // Do NOT exit -- MCP server should try to continue
   });
   process.on("unhandledRejection", (reason) => {
     const msg = reason instanceof Error ? reason.message : String(reason);
     logger.error(`Unhandled rejection: ${msg}`);
   });
   ```

3. Add graceful shutdown handlers:
   ```
   process.on("SIGTERM", () => { logger.info("SIGTERM received, shutting down"); logger.close(); process.exit(0); });
   process.on("SIGINT", () => { logger.info("SIGINT received, shutting down"); logger.close(); process.exit(0); });
   ```

4. Define `async function main()`:
   a. Call `await runStartup()` -- MUST complete before MCP transport starts (handles first-run prompt, config loading, logger init, validation).
   b. Create McpServer with name and version from constants.
   c. Register all 5 tools (same imports as current index.ts).
   d. Create StdioServerTransport and connect.
   e. Write startup banner to stderr directly: `process.stderr.write(\`${SERVER_NAME} v${SERVER_VERSION} running on stdio\n\`)` -- always prints regardless of log level.
   f. Log info: "Server ready. Tools: cc_register_peer, cc_deregister_peer, cc_send_message, cc_list_peers, cc_get_history".

5. Call `main().catch((err) => { ... })`:
   - Log error via logger.
   - Write to stderr as fallback (in case logger failed).
   - Call `logger.close()` and `process.exit(1)`.

Key: The startup banner is written directly to stderr, not through the logger, so it ALWAYS appears. The `runStartup()` call MUST happen before `server.connect(transport)` because the first-run prompt uses stdin.
  </action>
  <verify>
Run `npx tsc --noEmit` (ignoring cc-cli.ts errors). Verify index.ts compiles. Check that runStartup() is called before server.connect(). Check that global error handlers are registered. Check that no console.log or stdout writes exist.
  </verify>
  <done>
index.ts has the correct startup order: global handlers -> runStartup() -> create server -> register tools -> connect transport -> banner. Unhandled rejections and uncaught exceptions are caught and logged. SIGTERM/SIGINT flush logs. Startup banner always prints to stderr.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` produces errors ONLY in cc-cli.ts (expected, fixed in Plan 03)
2. Logger writes to stderr only (grep for "process.stdout" returns nothing in logger.ts)
3. Startup flow calls runStartup() before server.connect()
4. Global handlers registered for uncaughtException, unhandledRejection, SIGTERM, SIGINT
5. First-run prompt uses stderr for output and only activates when process.stdin.isTTY
6. State directory is auto-created with recursive: true
</verification>

<success_criteria>
- Logger writes to 3 destinations (stderr, text file, JSON file) and respects log level
- Startup validates state dir writability and checks for claude CLI
- First-run prompt works in TTY, uses defaults in non-TTY
- index.ts startup order is: handlers -> startup -> server -> transport
- No stdout pollution in any new file
</success_criteria>

<output>
After completion, create `.planning/phases/01-config-error-hardening/01-02-SUMMARY.md`
</output>
